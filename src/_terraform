#compdef terraform

__terraform_debug() {
    local file="$BASH_COMP_DEBUG_FILE"
    if [[ -n ${file} ]]; then
        echo "$*" >> "${file}"
    fi
}

# Cache the commands in a file to avoid running terraform -help too often
__terraform_commands_cache_file="${XDG_CACHE_HOME:-$HOME/.cache}/terraform_commands"

# Function to parse terraform commands and their descriptions
__terraform_parse_commands() {
    local help_text commands_text
    help_text=$(terraform -help 2>/dev/n

    # Extract the commands section from help text
    commands_text=$(echo "$help_text" | awk '/^Available commands are:/,/^$/' | tail -n

    # Create cache directory if it doesn't exist
    mkdir -p "$(dirname "$__terraform_commands_cache_file"

    # Parse and store commands in cache file
    echo "$commands_text" | while read -r line; do
        if [[ -n "$line" ]]; then
            # Extract command and description
            local cmd desc
            cmd=$(echo "$line" | awk '{print $1}')
            desc=$(echo "$line" | sed "s/^$cmd *//")
            echo "${cmd}:${desc}"
        fi
    done > "$__terraform_commands_cache_file"
}

# Function to get subcommands for a specific command
__terraform_parse_subcommands() {
    local cmd="$1"
    local help_text subcommands_text
    help_text=$(terraform $cmd -help 2>/dev/nul

    # Extract subcommands section if it exists
    subcommands_text=$(echo "$help_text" | awk '/^Subcommands:$/,/^$/' | tail -n +2

    # Parse and return subcommands
    echo "$subcommands_text" | while read -r line; do
        if [[ -n "$line" ]]; then
            local subcmd desc
            subcmd=$(echo "$line" | awk '{print $1}')
            desc=$(echo "$line" | sed "s/^$subcmd *//")
            echo "${subcmd}:${desc}"
        fi
    done
}

# Function to get flags for a command
__terraform_parse_flags() {
    local cmd="$1"
    local help_text flags_text
    help_text=$(terraform $cmd -help 2>/dev/null)
 
    # Extract flags section
    flags_text=$(echo "$help_text" | awk '/^[[:space:]]*-/,/^$/' | grep "^[[:space:]]*-")

    # Parse and return flags
    echo "$flags_text" | while read -r line; do
        if [[ -n "$line" ]]; then
            local flag desc
            flag=$(echo "$line" | awk '{print $1}')
            desc=$(echo "$line" | sed "s/^$flag *//")
            echo "${flag}:${desc}"
        fi
    done
}

_terraform() {
    local curcontext="$curcontext" state line ret=1
    local -A opt_args
    local -a commands subcommands flags

    # Check if we need to update the commands cache
    if [[ ! -f "$__terraform_commands_cache_file" ]] || \
       [[ $(find "$__terraform_commands_cache_file" -mtime +1) ]]; then
        __terraform_parse_commands
    fi

    # Read commands from cache
    commands=("${(@f)$(<$__terraform_commands_cache_file)}")

    _arguments -C \
        '1: :->cmds' \
        '*:: :->args'

    case $state in
        cmds)
            _describe -t commands 'terraform command' commands && ret=0
            ;;
        args)
            case $words[1] in
                state|workspace|providers)
                    # Get subcommands dynamically
                    subcommands=("${(f)$(terraform_parse_subcommands $words[1])}")
                    _describe -t subcmds "terraform $words[1] subcommand" subcommands && ret=0
                    ;;
                *)
                    # Get flags dynamically
                    flags=("${(f)$(__terraform_parse_flags $words[1])}")
                    _describe -t flags "terraform $words[1] flags" flags && ret=0
                    _files && ret=0
                    ;;
            esac
            ;;
    esac

    return ret
}

# don't run the completion function when being source-ed or eval-ed
if [ "$funcstack[1]" = "_terraform" ]; then
    _terraform
fi
